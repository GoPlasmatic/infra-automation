name: Deploy Applications
# Deploys Docker services and configures SSL

permissions:
  contents: read

on:
  push:
    branches:
      - main
    paths:
      - 'docker/**'
      - 'ansible/**'
      - '.github/workflows/deploy.yml'
  workflow_run:
    workflows: ["Terraform Infrastructure"]
    types:
      - completed
  workflow_dispatch:
    inputs:
      deploy_components:
        description: 'Components to deploy (comma-separated: nginx,monitoring,ghost,reframe,sandbox or "all")'
        required: false
        default: 'reframe,sandbox'
        type: string
      setup_ssl:
        description: 'Setup/renew SSL certificates'
        required: false
        default: 'true'
        type: choice
        options:
          - 'true'
          - 'false'

env:
  REGISTRY: ghcr.io

jobs:
  detect-changes:
    name: Detect Changes
    runs-on: ubuntu-latest
    outputs:
      nginx: ${{ steps.changes.outputs.nginx }}
      monitoring: ${{ steps.changes.outputs.monitoring }}
      ghost: ${{ steps.changes.outputs.ghost }}
      reframe: ${{ steps.changes.outputs.reframe }}
      sandbox: ${{ steps.changes.outputs.sandbox }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 2
      
      - name: Detect file changes
        id: changes
        run: |
          echo "Detecting changes..."
          
          # For manual trigger, check the inputs
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "Manual trigger detected. Processing deploy_components input..."
            COMPONENTS="${{ github.event.inputs.deploy_components }}"
            
            # Default to false for all components
            NGINX="false"
            MONITORING="false"
            GHOST="false"
            REFRAME="false"
            SANDBOX="false"
            
            # Check if "all" was specified
            if [ "$COMPONENTS" == "all" ]; then
              NGINX="true"
              MONITORING="true"
              GHOST="true"
              REFRAME="true"
              SANDBOX="true"
            else
              # Parse comma-separated components
              IFS=',' read -ra COMP_ARRAY <<< "$COMPONENTS"
              for comp in "${COMP_ARRAY[@]}"; do
                comp=$(echo "$comp" | xargs)  # Trim whitespace
                case "$comp" in
                  nginx) NGINX="true" ;;
                  monitoring) MONITORING="true" ;;
                  ghost) GHOST="true" ;;
                  reframe) REFRAME="true" ;;
                  sandbox) SANDBOX="true" ;;
                esac
              done
            fi
            
            echo "nginx=$NGINX" >> $GITHUB_OUTPUT
            echo "monitoring=$MONITORING" >> $GITHUB_OUTPUT
            echo "ghost=$GHOST" >> $GITHUB_OUTPUT
            echo "reframe=$REFRAME" >> $GITHUB_OUTPUT
            echo "sandbox=$SANDBOX" >> $GITHUB_OUTPUT
          else
            # Function to check if files changed
            check_changes() {
              local pattern=$1
              if git diff --name-only HEAD~1 HEAD | grep -q "$pattern"; then
                echo "true"
              else
                echo "false"
              fi
            }
            
            # For push events, always deploy all components
            if [ "${{ github.event_name }}" == "push" ]; then
              echo "Push event detected - deploying all components"
              echo "nginx=true" >> $GITHUB_OUTPUT
              echo "monitoring=true" >> $GITHUB_OUTPUT
              echo "ghost=true" >> $GITHUB_OUTPUT
              echo "reframe=true" >> $GITHUB_OUTPUT
              echo "sandbox=true" >> $GITHUB_OUTPUT
            else
              # Check each component for workflow_run
              echo "nginx=$(check_changes 'docker/nginx/\|docker/docker-compose.yml')" >> $GITHUB_OUTPUT
              echo "monitoring=$(check_changes 'docker/prometheus/\|docker/docker-compose.yml')" >> $GITHUB_OUTPUT
              echo "ghost=$(check_changes 'docker/ghost/\|docker/docker-compose.yml')" >> $GITHUB_OUTPUT
              echo "reframe=$(check_changes 'docker/docker-compose.yml')" >> $GITHUB_OUTPUT
              echo "sandbox=$(check_changes 'docker/docker-compose.yml')" >> $GITHUB_OUTPUT
            fi
          fi

  build-and-deploy:
    name: Build and Deploy
    needs: detect-changes
    runs-on: ubuntu-latest
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch' || github.event.workflow_run.conclusion == 'success'
    
    env:
      PROJECT_NAME: ${{ vars.PROJECT_NAME || 'multi-app-server' }}
      ENVIRONMENT: ${{ vars.ENVIRONMENT || 'production' }}
      DOMAIN_NAME: ${{ vars.DOMAIN_NAME }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Configure Azure credentials
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
      
      - name: Get VM IP
        id: get-ip
        run: |
          # Try to get from workflow artifact first
          if [ "${{ github.event_name }}" == "workflow_run" ]; then
            echo "Getting IP from Terraform workflow..."
            ARTIFACT_URL="${{ github.event.workflow_run.artifacts_url }}"
            ARTIFACT_ID=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" $ARTIFACT_URL | jq -r '.artifacts[] | select(.name=="terraform-outputs") | .id')
            
            if [ ! -z "$ARTIFACT_ID" ]; then
              curl -L -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                "https://api.github.com/repos/${{ github.repository }}/actions/artifacts/$ARTIFACT_ID/zip" \
                -o terraform-outputs.zip
              unzip terraform-outputs.zip
              VM_IP=$(cat vm_public_ip.txt)
            fi
          fi
          
          # If not found, try to resolve from DNS (since DNS is configured)
          if [ -z "$VM_IP" ]; then
            echo "Trying to get IP from DNS..."
            if [ -n "${DOMAIN_NAME}" ]; then
              VM_IP=$(dig +short ${DOMAIN_NAME} | tail -n1)
              if [ -n "$VM_IP" ]; then
                echo "Found IP from DNS: $VM_IP"
              fi
            fi
          fi
          
          # If still not found, get from Azure using default values
          if [ -z "$VM_IP" ]; then
            echo "Getting IP from Azure..."
            # Use default values if not set
            PROJECT_NAME=${PROJECT_NAME:-multi-app-server}
            ENVIRONMENT=${ENVIRONMENT:-production}
            echo "Using PROJECT_NAME=${PROJECT_NAME}, ENVIRONMENT=${ENVIRONMENT}"
            
            # Try to get VM IP from Azure
            VM_IP=$(az vm show -d -g ${PROJECT_NAME}-${ENVIRONMENT}-rg -n ${PROJECT_NAME}-${ENVIRONMENT}-vm --query publicIps -o tsv 2>/dev/null || echo "")
            
            if [ -n "$VM_IP" ]; then
              echo "Found IP from Azure: $VM_IP"
            fi
          fi
          
          # Final check
          if [ -z "$VM_IP" ]; then
            echo "Error: Could not determine VM IP dynamically"
            echo "Please ensure:"
            echo "  1. DOMAIN_NAME variable is set in repository settings"
            echo "  2. Azure credentials are configured correctly"
            echo "  3. VM exists in the expected resource group"
            exit 1
          fi
          
          echo "vm_ip=$VM_IP" >> $GITHUB_OUTPUT
      
      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ steps.get-ip.outputs.vm_ip }} >> ~/.ssh/known_hosts
      
      - name: Initial VM Setup
        env:
          ACR_URL: ${{ secrets.ACR_URL }}
          ACR_USERNAME: ${{ secrets.ACR_USERNAME }}
          ACR_PASSWORD: ${{ secrets.ACR_PASSWORD }}
        run: |
          echo "Setting up initial directories and Docker configuration..."
          
          # Copy all Docker configuration files
          scp -i ~/.ssh/deploy_key -r docker/* ${{ secrets.VM_ADMIN_USERNAME }}@${{ steps.get-ip.outputs.vm_ip }}:~/docker/
          
          # Copy and substitute secrets in .env file
          cp docker/.env /tmp/.env
          sed -i "s/\${MAILGUN_SMTP_PASSWORD}/${{ secrets.MAILGUN_SMTP_PASSWORD }}/g" /tmp/.env
          sed -i "s/\${GHOST_MYSQL_ROOT_PASSWORD}/${{ secrets.GHOST_MYSQL_ROOT_PASSWORD || 'ajQtVKFljU8PhSUCgtaOtGFzh' }}/g" /tmp/.env
          sed -i "s/\${GHOST_MYSQL_PASSWORD}/${{ secrets.GHOST_MYSQL_PASSWORD || 'mvconhsataCnVifw8YL99bofl' }}/g" /tmp/.env
          sed -i "s/\${GRAFANA_ADMIN_PASSWORD}/${{ secrets.GRAFANA_ADMIN_PASSWORD || '7C3bef505bEq2lzCVpvk4yP8U' }}/g" /tmp/.env
          # Add ACR URL to .env
          echo "ACR_URL=${ACR_URL}" >> /tmp/.env
          scp -i ~/.ssh/deploy_key /tmp/.env ${{ secrets.VM_ADMIN_USERNAME }}@${{ steps.get-ip.outputs.vm_ip }}:~/docker/.env
          rm /tmp/.env
          
          # Setup directories and move files
          ssh -i ~/.ssh/deploy_key ${{ secrets.VM_ADMIN_USERNAME }}@${{ steps.get-ip.outputs.vm_ip }} << EOF
            set -e

            # Create required directories
            sudo mkdir -p /opt/docker/{nginx/sites-enabled,nginx/snippets,prometheus,grafana/provisioning/datasources}
            sudo mkdir -p /opt/ghost
            sudo mkdir -p /var/www/certbot

            # Clean up specific known problematic configs from both filesystem and container
            echo "Cleaning up known problematic nginx configurations..."
            # Remove only specific configs that are known to cause issues
            PROBLEM_CONFIGS=("future.conf" "*.conf.disabled")
            for pattern in "\${PROBLEM_CONFIGS[@]}"; do
              # Clean from filesystem
              for file in /opt/docker/nginx/sites-enabled/\$pattern; do
                if [ -f "\$file" ]; then
                  echo "Removing problematic config from filesystem: \$(basename \$file)"
                  sudo rm -f "\$file"
                fi
              done
            done

            # Also clean from inside running container if it exists
            if sudo docker ps -a | grep -q main_nginx; then
              echo "Cleaning problematic configs from nginx container..."
              for pattern in "\${PROBLEM_CONFIGS[@]}"; do
                sudo docker exec main_nginx sh -c "rm -f /etc/nginx/sites-enabled/\$pattern 2>/dev/null" || true
              done
            fi

            # Move Docker files to proper location
            sudo cp -r ~/docker/* /opt/docker/
            sudo cp ~/docker/.env /opt/docker/.env
            
            # Set permissions
            sudo chown -R \$USER:docker /opt/docker
            sudo chmod -R 755 /opt/docker
            sudo chmod 640 /opt/docker/.env
            
            # Login to Azure Container Registry
            echo "Logging into Azure Container Registry..."
            echo "${ACR_PASSWORD}" | sudo docker login ${ACR_URL} \
              --username ${ACR_USERNAME} \
              --password-stdin
            
            echo "Initial setup completed"
          EOF
      
      - name: Configure Domain Names
        run: |
          echo "Configuring domain: ${DOMAIN_NAME}"
          
          # Copy configuration script
          scp -i ~/.ssh/deploy_key scripts/configure-nginx-domains.sh ${{ secrets.VM_ADMIN_USERNAME }}@${{ steps.get-ip.outputs.vm_ip }}:~/
          
          # Run configuration
          ssh -i ~/.ssh/deploy_key ${{ secrets.VM_ADMIN_USERNAME }}@${{ steps.get-ip.outputs.vm_ip }} << EOF
            chmod +x ~/configure-nginx-domains.sh
            sudo ~/configure-nginx-domains.sh "${DOMAIN_NAME}"
          EOF
      
      - name: Deploy Nginx
        if: needs.detect-changes.outputs.nginx == 'true'
        run: |
          echo "Deploying Nginx configuration..."
          
          # Create nginx directory on remote first
          ssh -i ~/.ssh/deploy_key ${{ secrets.VM_ADMIN_USERNAME }}@${{ steps.get-ip.outputs.vm_ip }} "mkdir -p ~/nginx"
          
          # Copy nginx config
          scp -i ~/.ssh/deploy_key -r docker/nginx/* ${{ secrets.VM_ADMIN_USERNAME }}@${{ steps.get-ip.outputs.vm_ip }}:~/nginx/
          
          # Update and restart nginx
          ssh -i ~/.ssh/deploy_key ${{ secrets.VM_ADMIN_USERNAME }}@${{ steps.get-ip.outputs.vm_ip }} << 'EOF'
            set -e

            # List current configs for reference
            echo "Current nginx configs in ~/nginx/sites-enabled:"
            ls -la ~/nginx/sites-enabled/ 2>/dev/null || echo "No sites-enabled directory"

            # Clean up only specific known obsolete configs - both in filesystem and container
            echo "Checking for obsolete nginx configs to remove..."

            # First, clean up from the filesystem
            OBSOLETE_CONFIGS=("future.conf" "website-old.conf" "*.conf.disabled")
            for pattern in "${OBSOLETE_CONFIGS[@]}"; do
              for file in /opt/docker/nginx/sites-enabled/$pattern; do
                if [ -f "$file" ]; then
                  echo "Removing obsolete config from filesystem: $(basename $file)"
                  sudo rm -f "$file"
                fi
              done
            done

            # Also clean up from inside the running container if it exists
            if sudo docker ps -a | grep -q main_nginx; then
              echo "Cleaning obsolete configs from nginx container..."
              for pattern in "${OBSOLETE_CONFIGS[@]}"; do
                sudo docker exec main_nginx sh -c "rm -f /etc/nginx/sites-enabled/$pattern 2>/dev/null" || true
              done
            fi

            # Backup existing nginx directory before overwriting
            if [ -d /opt/docker/nginx ]; then
              sudo cp -r /opt/docker/nginx /opt/docker/nginx.backup.$(date +%s) 2>/dev/null || true
            fi

            # Now copy new configs (preserving mime.types and other essential files)
            sudo cp -r ~/nginx/* /opt/docker/nginx/
            cd /opt/docker

            # Skip nginx config test - it will be validated when the container starts
            # The test fails in isolation due to upstream hosts not being resolvable
            # which is expected behavior during deployment
            echo "Nginx configuration will be validated when container starts..."
            echo "Note: Configuration testing in isolation is skipped as upstream services may not be running"

            # Restart nginx
            sudo docker compose restart nginx

            # Verify nginx started successfully
            echo "Waiting for nginx to start..."
            sleep 5

            # Check nginx status
            NGINX_STATUS=$(sudo docker ps --filter "name=main_nginx" --format "{{.Status}}" | head -1)
            echo "Nginx status: $NGINX_STATUS"

            if echo "$NGINX_STATUS" | grep -q "Up.*healthy"; then
              echo "âœ“ Nginx restarted successfully and is healthy"
            elif echo "$NGINX_STATUS" | grep -q "Restarting"; then
              echo "âœ— ERROR: Nginx is in a restart loop!"
              echo "Checking nginx logs for errors:"
              sudo docker logs main_nginx --tail 30
              echo ""
              echo "Common issues:"
              echo "- Duplicate upstream definitions"
              echo "- Missing SSL certificates"
              echo "- Port conflicts"
              exit 1
            else
              echo "âš  Warning: Nginx status unclear, checking logs..."
              sudo docker logs main_nginx --tail 20
              # Don't fail here, let health checks handle it
            fi
          EOF
      
      - name: Deploy Monitoring
        if: needs.detect-changes.outputs.monitoring == 'true'
        run: |
          echo "Deploying monitoring stack..."
          
          # Create prometheus directory on remote first
          ssh -i ~/.ssh/deploy_key ${{ secrets.VM_ADMIN_USERNAME }}@${{ steps.get-ip.outputs.vm_ip }} "mkdir -p ~/prometheus"
          
          # Copy prometheus config
          scp -i ~/.ssh/deploy_key -r docker/prometheus/* ${{ secrets.VM_ADMIN_USERNAME }}@${{ steps.get-ip.outputs.vm_ip }}:~/prometheus/
          
          # Update and restart monitoring
          ssh -i ~/.ssh/deploy_key ${{ secrets.VM_ADMIN_USERNAME }}@${{ steps.get-ip.outputs.vm_ip }} << 'EOF'
            set -e
            sudo mkdir -p /opt/docker/prometheus
            sudo cp -r ~/prometheus/* /opt/docker/prometheus/
            cd /opt/docker
            sudo docker compose restart prometheus grafana
          EOF
      
      - name: Deploy Ghost
        if: needs.detect-changes.outputs.ghost == 'true'
        run: |
          echo "Deploying Ghost CMS..."
          
          ssh -i ~/.ssh/deploy_key ${{ secrets.VM_ADMIN_USERNAME }}@${{ steps.get-ip.outputs.vm_ip }} << 'EOF'
            set -e
            cd /opt/docker
            
            # Enable Ghost in docker-compose
            sudo sed -i 's/#ghost:/ghost:/' docker-compose.yml
            sudo sed -i 's/#  ghost_/  ghost_/' docker-compose.yml
            
            # Start Ghost containers
            sudo docker compose up -d ghost ghost_db
            
            # Enable Ghost nginx configs
            sudo mv /opt/docker/nginx/sites-enabled/ghost-admin.conf.disabled /opt/docker/nginx/sites-enabled/ghost-admin.conf || true
            
            sudo docker compose restart nginx
          EOF
      
      - name: Deploy Reframe
        if: needs.detect-changes.outputs.reframe == 'true'
        env:
          ACR_URL: ${{ secrets.ACR_URL }}
          ACR_USERNAME: ${{ secrets.ACR_USERNAME }}
          ACR_PASSWORD: ${{ secrets.ACR_PASSWORD }}
        run: |
          echo "Deploying Reframe API from Azure Container Registry..."
          
          ssh -i ~/.ssh/deploy_key ${{ secrets.VM_ADMIN_USERNAME }}@${{ steps.get-ip.outputs.vm_ip }} << EOF
            set -e
            
            # Login to Azure Container Registry
            echo "Logging into Azure Container Registry..."
            echo "${ACR_PASSWORD}" | sudo docker login ${ACR_URL} \
              --username ${ACR_USERNAME} \
              --password-stdin
            
            # Update .env file with ACR URL
            echo "ACR_URL=${ACR_URL}" | sudo tee -a /opt/docker/.env > /dev/null
            
            # Pull latest Reframe image
            echo "Pulling latest Reframe image from ACR..."
            sudo docker pull ${ACR_URL}/reframe:latest
            
            # Start Reframe container using docker-compose
            cd /opt/docker
            sudo docker compose up -d reframe
            
            # Health check
            echo "Waiting for Reframe to start..."
            sleep 15
            
            # Check if container is running
            if sudo docker ps | grep -q reframe_api; then
              echo "âœ“ Reframe container is running"
              
              # Test API endpoint
              if curl -f -s -o /dev/null -w "Reframe API Health: %{http_code}\n" http://localhost:3000/health; then
                echo "âœ“ Reframe API is responding"
              else
                echo "âš  Reframe API health check failed"
                sudo docker logs reframe_api --tail 50
              fi
            else
              echo "âœ— Reframe container failed to start"
              sudo docker logs reframe_api --tail 50
              exit 1
            fi
          EOF
      
      - name: Deploy Sandbox
        if: needs.detect-changes.outputs.sandbox == 'true'
        env:
          ACR_URL: ${{ secrets.ACR_URL }}
        run: |
          echo "Deploying Sandbox website from Azure Container Registry..."
          
          ssh -i ~/.ssh/deploy_key ${{ secrets.VM_ADMIN_USERNAME }}@${{ steps.get-ip.outputs.vm_ip }} << EOF
            set -e
            
            # Pull latest Sandbox image (ACR login already done in initial setup)
            echo "Pulling latest Sandbox image from ACR..."
            sudo docker pull ${ACR_URL}/sandbox:latest
            
            # Start Sandbox container using docker-compose
            cd /opt/docker
            sudo docker compose up -d sandbox
            
            # Health check
            echo "Waiting for Sandbox to start..."
            sleep 10
            
            # Check if container is running
            if sudo docker ps | grep -q sandbox_website; then
              echo "âœ“ Sandbox container is running"
              
              # Test website endpoint
              if curl -f -s -o /dev/null -w "Sandbox Website: %{http_code}\n" http://localhost:3000; then
                echo "âœ“ Sandbox website is responding"
              else
                echo "âš  Sandbox website health check failed"
                sudo docker logs sandbox_website --tail 50
              fi
            else
              echo "âœ— Sandbox container failed to start"
              sudo docker logs sandbox_website --tail 50
              exit 1
            fi
          EOF
      
      - name: Run health checks
        run: |
          VM_IP=${{ steps.get-ip.outputs.vm_ip }}

          echo "Running health checks..."
          echo "Note: Services may take a moment to fully start"

          # Give services time to start
          sleep 30

          # Check all container statuses
          echo "Checking Docker container health..."
          ssh -i ~/.ssh/deploy_key ${{ secrets.VM_ADMIN_USERNAME }}@$VM_IP << 'EOF'
            set -e

            # Check nginx is healthy
            if sudo docker ps | grep -q "main_nginx.*Up.*healthy"; then
              echo "âœ“ Nginx is healthy"
            elif sudo docker ps | grep -q "main_nginx.*Restarting"; then
              echo "âœ— ERROR: Nginx is in restart loop!"
              echo "Nginx logs:"
              sudo docker logs main_nginx --tail 30

              # Try to identify and fix common issues
              echo "Checking for duplicate upstream definitions..."
              sudo docker run --rm -v /opt/docker/nginx:/etc/nginx:ro nginx:alpine nginx -T 2>&1 | grep -E "duplicate upstream" || true
              exit 1
            else
              echo "âš  Warning: Nginx status unknown"
              sudo docker ps | grep nginx || true
            fi

            # Check other critical services
            SERVICES=("ghost_cms" "reframe_api" "sandbox_website")
            for service in "${SERVICES[@]}"; do
              if sudo docker ps | grep -q "$service.*Up"; then
                echo "âœ“ $service is running"
              else
                echo "âš  Warning: $service may not be running properly"
              fi
            done

            echo ""
            echo "Container Summary:"
            sudo docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
          EOF

          # Check main website (nginx default or website)
          curl -f -s -o /dev/null -w "Website HTTP check: %{http_code}\n" http://$VM_IP || true

          echo "Health checks completed. Services should be accessible via domain names after DNS propagation."
      
      - name: Setup SSL Certificates
        if: github.event_name == 'workflow_run' || github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && github.event.inputs.setup_ssl != 'false')
        run: |
          VM_IP=${{ steps.get-ip.outputs.vm_ip }}
          EMAIL="${{ secrets.EMAIL_ADDRESS }}"
          DOMAIN="${DOMAIN_NAME}"
          
          echo "Checking SSL certificates status..."
          
          # Check if certificates already exist and are valid
          CERT_CHECK=$(ssh -i ~/.ssh/deploy_key ${{ secrets.VM_ADMIN_USERNAME }}@$VM_IP << EOF || echo "NEEDS_SETUP"
            # Check if main certificate exists and is valid
            DOMAIN_NAME="${DOMAIN}"
            if [ -f /etc/letsencrypt/live/www.\${DOMAIN_NAME}/fullchain.pem ]; then
              # Check expiry date (renew if less than 30 days remaining)
              if openssl x509 -checkend 2592000 -noout -in /etc/letsencrypt/live/www.\${DOMAIN_NAME}/fullchain.pem 2>/dev/null; then
                echo "VALID"
              else
                echo "EXPIRING_SOON"
              fi
            else
              echo "NEEDS_SETUP"
            fi
          EOF
          )
          
          if [ "$CERT_CHECK" = "VALID" ]; then
            echo "âœ“ SSL certificates are valid and not expiring soon. Skipping renewal."
          else
            if [ "$CERT_CHECK" = "EXPIRING_SOON" ]; then
              echo "âš  SSL certificates expiring within 30 days. Renewing..."
            else
              echo "ðŸ“‹ Setting up SSL certificates for the first time..."
            fi
            
            # Copy SSL setup script to server
            scp -i ~/.ssh/deploy_key scripts/setup-ssl-automated.sh ${{ secrets.VM_ADMIN_USERNAME }}@$VM_IP:~/
            
            # Run SSL setup
            ssh -i ~/.ssh/deploy_key ${{ secrets.VM_ADMIN_USERNAME }}@$VM_IP << EOF
              chmod +x ~/setup-ssl-automated.sh
              ~/setup-ssl-automated.sh $VM_IP "$EMAIL" "$DOMAIN"
          EOF
            
            echo "SSL setup completed"
          fi
      
      - name: Cleanup
        if: always()
        run: |
          rm -f ~/.ssh/deploy_key
          rm -f terraform-outputs.zip vm_public_ip.txt storage_account.txt