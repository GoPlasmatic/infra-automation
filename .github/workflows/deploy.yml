name: Deploy Applications
# Deploys Docker services and configures SSL

permissions:
  contents: read

on:
  push:
    branches:
      - main
    paths:
      - 'docker/**'
      - 'ansible/**'
      - '.github/workflows/deploy.yml'
  workflow_run:
    workflows: ["Terraform Infrastructure"]
    types:
      - completed
  workflow_dispatch:
    inputs:
      deploy_components:
        description: 'Components to deploy (comma-separated: nginx,monitoring,ghost,reframe,sandbox or "all")'
        required: false
        default: 'reframe,sandbox'
        type: string
      setup_ssl:
        description: 'Setup/renew SSL certificates'
        required: false
        default: 'true'
        type: choice
        options:
          - 'true'
          - 'false'

env:
  REGISTRY: ghcr.io

jobs:
  detect-changes:
    name: Detect Changes
    runs-on: ubuntu-latest
    outputs:
      nginx: ${{ steps.changes.outputs.nginx }}
      monitoring: ${{ steps.changes.outputs.monitoring }}
      ghost: ${{ steps.changes.outputs.ghost }}
      reframe: ${{ steps.changes.outputs.reframe }}
      sandbox: ${{ steps.changes.outputs.sandbox }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 2
      
      - name: Detect file changes
        id: changes
        run: |
          echo "Detecting changes..."
          
          # For manual trigger, check the inputs
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "Manual trigger detected. Processing deploy_components input..."
            COMPONENTS="${{ github.event.inputs.deploy_components }}"
            
            # Default to false for all components
            NGINX="false"
            MONITORING="false"
            GHOST="false"
            REFRAME="false"
            SANDBOX="false"
            
            # Check if "all" was specified
            if [ "$COMPONENTS" == "all" ]; then
              NGINX="true"
              MONITORING="true"
              GHOST="true"
              REFRAME="true"
              SANDBOX="true"
            else
              # Parse comma-separated components
              IFS=',' read -ra COMP_ARRAY <<< "$COMPONENTS"
              for comp in "${COMP_ARRAY[@]}"; do
                comp=$(echo "$comp" | xargs)  # Trim whitespace
                case "$comp" in
                  nginx) NGINX="true" ;;
                  monitoring) MONITORING="true" ;;
                  ghost) GHOST="true" ;;
                  reframe) REFRAME="true" ;;
                  sandbox) SANDBOX="true" ;;
                esac
              done
            fi
            
            echo "nginx=$NGINX" >> $GITHUB_OUTPUT
            echo "monitoring=$MONITORING" >> $GITHUB_OUTPUT
            echo "ghost=$GHOST" >> $GITHUB_OUTPUT
            echo "reframe=$REFRAME" >> $GITHUB_OUTPUT
            echo "sandbox=$SANDBOX" >> $GITHUB_OUTPUT
          else
            # Function to check if files changed
            check_changes() {
              local pattern=$1
              if git diff --name-only HEAD~1 HEAD | grep -q "$pattern"; then
                echo "true"
              else
                echo "false"
              fi
            }
            
            # For push events, always deploy all components
            if [ "${{ github.event_name }}" == "push" ]; then
              echo "Push event detected - deploying all components"
              echo "nginx=true" >> $GITHUB_OUTPUT
              echo "monitoring=true" >> $GITHUB_OUTPUT
              echo "ghost=true" >> $GITHUB_OUTPUT
              echo "reframe=true" >> $GITHUB_OUTPUT
              echo "sandbox=true" >> $GITHUB_OUTPUT
            else
              # Check each component for workflow_run
              echo "nginx=$(check_changes 'docker/nginx/\|docker/docker-compose.yml')" >> $GITHUB_OUTPUT
              echo "monitoring=$(check_changes 'docker/prometheus/\|docker/docker-compose.yml')" >> $GITHUB_OUTPUT
              echo "ghost=$(check_changes 'docker/ghost/\|docker/docker-compose.yml')" >> $GITHUB_OUTPUT
              echo "reframe=$(check_changes 'docker/docker-compose.yml')" >> $GITHUB_OUTPUT
              echo "sandbox=$(check_changes 'docker/docker-compose.yml')" >> $GITHUB_OUTPUT
            fi
          fi

  build-and-deploy:
    name: Build and Deploy
    needs: detect-changes
    runs-on: ubuntu-latest
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch' || github.event.workflow_run.conclusion == 'success'
    
    env:
      PROJECT_NAME: ${{ vars.PROJECT_NAME || 'multi-app-server' }}
      ENVIRONMENT: ${{ vars.ENVIRONMENT || 'production' }}
      DOMAIN_NAME: ${{ vars.DOMAIN_NAME }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Configure Azure credentials
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
      
      - name: Get VM IP
        id: get-ip
        run: |
          # Try to get from workflow artifact first
          if [ "${{ github.event_name }}" == "workflow_run" ]; then
            echo "Getting IP from Terraform workflow..."
            ARTIFACT_URL="${{ github.event.workflow_run.artifacts_url }}"
            ARTIFACT_ID=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" $ARTIFACT_URL | jq -r '.artifacts[] | select(.name=="terraform-outputs") | .id')
            
            if [ ! -z "$ARTIFACT_ID" ]; then
              curl -L -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                "https://api.github.com/repos/${{ github.repository }}/actions/artifacts/$ARTIFACT_ID/zip" \
                -o terraform-outputs.zip
              unzip terraform-outputs.zip
              VM_IP=$(cat vm_public_ip.txt)
            fi
          fi
          
          # If not found, try to resolve from DNS (since DNS is configured)
          if [ -z "$VM_IP" ]; then
            echo "Trying to get IP from DNS..."
            if [ -n "${DOMAIN_NAME}" ]; then
              VM_IP=$(dig +short ${DOMAIN_NAME} | tail -n1)
              if [ -n "$VM_IP" ]; then
                echo "Found IP from DNS: $VM_IP"
              fi
            fi
          fi
          
          # If still not found, get from Azure using default values
          if [ -z "$VM_IP" ]; then
            echo "Getting IP from Azure..."
            # Use default values if not set
            PROJECT_NAME=${PROJECT_NAME:-multi-app-server}
            ENVIRONMENT=${ENVIRONMENT:-production}
            echo "Using PROJECT_NAME=${PROJECT_NAME}, ENVIRONMENT=${ENVIRONMENT}"
            
            # Try to get VM IP from Azure
            VM_IP=$(az vm show -d -g ${PROJECT_NAME}-${ENVIRONMENT}-rg -n ${PROJECT_NAME}-${ENVIRONMENT}-vm --query publicIps -o tsv 2>/dev/null || echo "")
            
            if [ -n "$VM_IP" ]; then
              echo "Found IP from Azure: $VM_IP"
            fi
          fi
          
          # Final check
          if [ -z "$VM_IP" ]; then
            echo "Error: Could not determine VM IP dynamically"
            echo "Please ensure:"
            echo "  1. DOMAIN_NAME variable is set in repository settings"
            echo "  2. Azure credentials are configured correctly"
            echo "  3. VM exists in the expected resource group"
            exit 1
          fi
          
          echo "vm_ip=$VM_IP" >> $GITHUB_OUTPUT
      
      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ steps.get-ip.outputs.vm_ip }} >> ~/.ssh/known_hosts
      
      - name: Initial VM Setup
        env:
          ACR_URL: ${{ secrets.ACR_URL }}
          ACR_USERNAME: ${{ secrets.ACR_USERNAME }}
          ACR_PASSWORD: ${{ secrets.ACR_PASSWORD }}
        run: |
          echo "Setting up initial directories and Docker configuration..."
          
          # Copy all Docker configuration files
          scp -i ~/.ssh/deploy_key -r docker/* ${{ secrets.VM_ADMIN_USERNAME }}@${{ steps.get-ip.outputs.vm_ip }}:~/docker/
          
          # Copy and substitute secrets in .env file
          cp docker/.env /tmp/.env
          sed -i "s/\${MAILGUN_SMTP_PASSWORD}/${{ secrets.MAILGUN_SMTP_PASSWORD }}/g" /tmp/.env
          sed -i "s/\${GHOST_MYSQL_ROOT_PASSWORD}/${{ secrets.GHOST_MYSQL_ROOT_PASSWORD || 'ajQtVKFljU8PhSUCgtaOtGFzh' }}/g" /tmp/.env
          sed -i "s/\${GHOST_MYSQL_PASSWORD}/${{ secrets.GHOST_MYSQL_PASSWORD || 'mvconhsataCnVifw8YL99bofl' }}/g" /tmp/.env
          sed -i "s/\${GRAFANA_ADMIN_PASSWORD}/${{ secrets.GRAFANA_ADMIN_PASSWORD || '7C3bef505bEq2lzCVpvk4yP8U' }}/g" /tmp/.env
          # Add ACR URL to .env
          echo "ACR_URL=${ACR_URL}" >> /tmp/.env
          scp -i ~/.ssh/deploy_key /tmp/.env ${{ secrets.VM_ADMIN_USERNAME }}@${{ steps.get-ip.outputs.vm_ip }}:~/docker/.env
          rm /tmp/.env
          
          # Setup directories and move files
          ssh -i ~/.ssh/deploy_key ${{ secrets.VM_ADMIN_USERNAME }}@${{ steps.get-ip.outputs.vm_ip }} << EOF
            set -e

            # Create required directories
            sudo mkdir -p /opt/docker/{nginx/sites-enabled,nginx/snippets,prometheus,grafana/provisioning/datasources}
            sudo mkdir -p /opt/ghost
            sudo mkdir -p /var/www/certbot

            # Clean up specific known problematic configs from both filesystem and container
            echo "Cleaning up known problematic nginx configurations..."
            # Remove only specific configs that are known to cause issues
            PROBLEM_CONFIGS=("future.conf" "*.conf.disabled")
            for pattern in "\${PROBLEM_CONFIGS[@]}"; do
              # Clean from filesystem
              for file in /opt/docker/nginx/sites-enabled/\$pattern; do
                if [ -f "\$file" ]; then
                  echo "Removing problematic config from filesystem: \$(basename \$file)"
                  sudo rm -f "\$file"
                fi
              done
            done

            # Also clean from inside running container if it exists
            if sudo docker ps -a | grep -q main_nginx; then
              echo "Cleaning problematic configs from nginx container..."
              for pattern in "\${PROBLEM_CONFIGS[@]}"; do
                sudo docker exec main_nginx sh -c "rm -f /etc/nginx/sites-enabled/\$pattern 2>/dev/null" || true
              done
            fi

            # Move Docker files to proper location
            sudo cp -r ~/docker/* /opt/docker/
            sudo cp ~/docker/.env /opt/docker/.env
            
            # Set permissions
            sudo chown -R \$USER:docker /opt/docker
            sudo chmod -R 755 /opt/docker
            sudo chmod 640 /opt/docker/.env
            
            # Login to Azure Container Registry
            echo "Logging into Azure Container Registry..."
            echo "${ACR_PASSWORD}" | sudo docker login ${ACR_URL} \
              --username ${ACR_USERNAME} \
              --password-stdin
            
            echo "Initial setup completed"
          EOF
      
      - name: Configure Domain Names
        run: |
          echo "Configuring domain: ${DOMAIN_NAME}"
          
          # Copy configuration script
          scp -i ~/.ssh/deploy_key scripts/configure-nginx-domains.sh ${{ secrets.VM_ADMIN_USERNAME }}@${{ steps.get-ip.outputs.vm_ip }}:~/
          
          # Run configuration
          ssh -i ~/.ssh/deploy_key ${{ secrets.VM_ADMIN_USERNAME }}@${{ steps.get-ip.outputs.vm_ip }} << EOF
            chmod +x ~/configure-nginx-domains.sh
            sudo ~/configure-nginx-domains.sh "${DOMAIN_NAME}"
          EOF
      
      - name: Deploy Nginx
        if: needs.detect-changes.outputs.nginx == 'true'
        run: |
          echo "Deploying Nginx configuration..."

          # Clean and recreate nginx directory on remote to avoid stale files
          ssh -i ~/.ssh/deploy_key ${{ secrets.VM_ADMIN_USERNAME }}@${{ steps.get-ip.outputs.vm_ip }} "rm -rf ~/nginx && mkdir -p ~/nginx"

          # Copy nginx config
          scp -i ~/.ssh/deploy_key -r docker/nginx/* ${{ secrets.VM_ADMIN_USERNAME }}@${{ steps.get-ip.outputs.vm_ip }}:~/nginx/
          
          # Update and restart nginx
          ssh -i ~/.ssh/deploy_key ${{ secrets.VM_ADMIN_USERNAME }}@${{ steps.get-ip.outputs.vm_ip }} << 'EOF'
            set -e

            # List current configs for reference
            echo "Current nginx configs in ~/nginx/sites-enabled:"
            ls -la ~/nginx/sites-enabled/ 2>/dev/null || echo "No sites-enabled directory"

            # Stop nginx container FIRST to ensure clean config replacement
            echo "Stopping nginx container to replace configs..."
            cd /opt/docker
            sudo docker compose stop nginx

            # Clean up only specific known obsolete configs from the filesystem
            echo "Removing obsolete nginx configs..."
            OBSOLETE_CONFIGS=("future.conf" "website-old.conf" "*.conf.disabled")
            for pattern in "${OBSOLETE_CONFIGS[@]}"; do
              for file in /opt/docker/nginx/sites-enabled/$pattern; do
                if [ -f "$file" ]; then
                  echo "  Removing: $(basename $file)"
                  sudo rm -f "$file"
                fi
              done
            done

            # Backup existing nginx directory before overwriting
            if [ -d /opt/docker/nginx ]; then
              echo "Creating backup of current nginx config..."
              sudo cp -r /opt/docker/nginx /opt/docker/nginx.backup.$(date +%s) 2>/dev/null || true
            fi

            # Copy new configs (preserving mime.types and other essential files)
            echo "Copying new nginx configs..."
            sudo cp -r ~/nginx/* /opt/docker/nginx/

            # List final config files
            echo "Final nginx config files:"
            ls -la /opt/docker/nginx/sites-enabled/

            # Start nginx with fresh configs
            echo "Starting nginx with new configuration..."
            sudo docker compose up -d nginx

            # Verify nginx started successfully
            echo "Waiting for nginx to start..."
            sleep 5

            # Check nginx status
            NGINX_STATUS=$(sudo docker ps --filter "name=main_nginx" --format "{{.Status}}" | head -1)
            echo "Nginx status: $NGINX_STATUS"

            if echo "$NGINX_STATUS" | grep -q "Up.*healthy"; then
              echo "âœ“ Nginx restarted successfully and is healthy"
            elif echo "$NGINX_STATUS" | grep -q "Restarting"; then
              echo "âœ— ERROR: Nginx is in a restart loop!"
              echo "Checking nginx logs for errors:"
              sudo docker logs main_nginx --tail 30
              echo ""
              echo "Common issues:"
              echo "- Duplicate upstream definitions"
              echo "- Missing SSL certificates"
              echo "- Port conflicts"
              exit 1
            else
              echo "âš  Warning: Nginx status unclear, checking logs..."
              sudo docker logs main_nginx --tail 20
              # Don't fail here, let health checks handle it
            fi
          EOF
      
      - name: Deploy Monitoring
        if: needs.detect-changes.outputs.monitoring == 'true'
        run: |
          echo "Deploying monitoring stack..."
          
          # Create prometheus directory on remote first
          ssh -i ~/.ssh/deploy_key ${{ secrets.VM_ADMIN_USERNAME }}@${{ steps.get-ip.outputs.vm_ip }} "mkdir -p ~/prometheus"
          
          # Copy prometheus config
          scp -i ~/.ssh/deploy_key -r docker/prometheus/* ${{ secrets.VM_ADMIN_USERNAME }}@${{ steps.get-ip.outputs.vm_ip }}:~/prometheus/
          
          # Update and restart monitoring
          ssh -i ~/.ssh/deploy_key ${{ secrets.VM_ADMIN_USERNAME }}@${{ steps.get-ip.outputs.vm_ip }} << 'EOF'
            set -e
            sudo mkdir -p /opt/docker/prometheus
            sudo cp -r ~/prometheus/* /opt/docker/prometheus/
            cd /opt/docker
            sudo docker compose restart prometheus grafana
          EOF
      
      - name: Deploy Ghost
        if: needs.detect-changes.outputs.ghost == 'true'
        run: |
          echo "Deploying Ghost CMS..."
          
          ssh -i ~/.ssh/deploy_key ${{ secrets.VM_ADMIN_USERNAME }}@${{ steps.get-ip.outputs.vm_ip }} << 'EOF'
            set -e
            cd /opt/docker
            
            # Enable Ghost in docker-compose
            sudo sed -i 's/#ghost:/ghost:/' docker-compose.yml
            sudo sed -i 's/#  ghost_/  ghost_/' docker-compose.yml
            
            # Start Ghost containers
            sudo docker compose up -d ghost ghost_db
            
            # Enable Ghost nginx configs
            sudo mv /opt/docker/nginx/sites-enabled/ghost-admin.conf.disabled /opt/docker/nginx/sites-enabled/ghost-admin.conf || true
            
            sudo docker compose restart nginx
          EOF
      
      - name: Deploy Reframe (with MongoDB)
        if: needs.detect-changes.outputs.reframe == 'true'
        env:
          ACR_URL: ${{ secrets.ACR_URL }}
          ACR_USERNAME: ${{ secrets.ACR_USERNAME }}
          ACR_PASSWORD: ${{ secrets.ACR_PASSWORD }}
        run: |
          echo "========================================"
          echo "Deploying Reframe API with MongoDB"
          echo "========================================"

          # Export vars for SSH session
          ACR_URL="${{ secrets.ACR_URL }}"
          ACR_USERNAME="${{ secrets.ACR_USERNAME }}"
          ACR_PASSWORD="${{ secrets.ACR_PASSWORD }}"

          ssh -i ~/.ssh/deploy_key ${{ secrets.VM_ADMIN_USERNAME }}@${{ steps.get-ip.outputs.vm_ip }} \
            "ACR_URL='${ACR_URL}' ACR_USERNAME='${ACR_USERNAME}' ACR_PASSWORD='${ACR_PASSWORD}' bash -s" << 'ENDSSH'
            set -e
            cd /opt/docker

            # Login to Azure Container Registry
            echo "Step 1/5: Logging into Azure Container Registry..."
            echo "${ACR_PASSWORD}" | sudo docker login ${ACR_URL} \
              --username ${ACR_USERNAME} \
              --password-stdin

            # Update .env file with ACR URL
            echo "ACR_URL=${ACR_URL}" | sudo tee -a .env > /dev/null

            # Backup current nginx config before any changes
            echo "Step 2/5: Creating rollback point..."
            sudo cp -r nginx nginx.rollback.$(date +%s) 2>/dev/null || true

            # STAGE 1: Deploy MongoDB first (if not already running)
            echo "Step 3/5: Deploying MongoDB database..."
            if ! sudo docker ps | grep -q reframe_db; then
              echo "  Starting MongoDB container..."
              sudo docker compose up -d reframe_db

              # Wait for MongoDB to be healthy
              echo "  Waiting for MongoDB to be healthy (max 60s)..."
              for i in {1..30}; do
                if sudo docker ps | grep -q "reframe_db.*healthy"; then
                  echo "  âœ“ MongoDB is healthy"
                  break
                fi
                if [ $i -eq 30 ]; then
                  echo "  âœ— MongoDB failed to become healthy"
                  sudo docker logs reframe_db --tail 30
                  exit 1
                fi
                sleep 2
              done
            else
              echo "  MongoDB already running"
            fi

            # STAGE 2: Pull and deploy Reframe
            echo "Step 4/5: Deploying Reframe API..."
            echo "  Pulling latest Reframe image from ACR..."
            sudo docker pull ${ACR_URL}/reframe:latest

            # Deploy Reframe WITHOUT restarting nginx
            echo "  Starting Reframe container..."
            sudo docker compose up -d --no-deps reframe

            # STAGE 3: Wait for Reframe to be ready before touching nginx
            echo "Step 5/5: Verifying Reframe health..."
            echo "  Waiting for Reframe health endpoint (max 120s)..."
            echo "  Note: Reframe needs ~70s to initialize before /health is available"
            REFRAME_HEALTHY=false
            for i in {1..60}; do
              # Test the health endpoint directly instead of waiting for Docker status
              if sudo docker exec reframe_api curl -f -s http://localhost:3000/health > /dev/null 2>&1; then
                echo ""
                echo "  âœ“ Reframe health endpoint responding"
                REFRAME_HEALTHY=true
                break
              fi
              if [ $i -eq 60 ]; then
                echo ""
                echo "  âœ— Reframe health endpoint not responding after 120 seconds"
                echo "  Container status:"
                sudo docker ps | grep reframe_api
                echo "  Reframe logs:"
                sudo docker logs reframe_api --tail 50
                exit 1
              fi
              echo -n "."
              sleep 2
            done

            # Verify API endpoint responds
            if [ "$REFRAME_HEALTHY" = true ]; then
              echo "  Testing Reframe API endpoint..."
              if curl -f -s -o /dev/null -w "  Reframe API Health: %{http_code}\n" http://localhost:3000/health; then
                echo "  âœ“ Reframe API is responding correctly"
              else
                echo "  âš  Reframe API health endpoint not responding"
                sudo docker logs reframe_api --tail 30
                # Don't fail, nginx will handle it gracefully
              fi
            fi

            echo ""
            echo "âœ… Reframe deployment completed successfully"
            echo "   MongoDB: Running and healthy"
            echo "   Reframe: Running and healthy"
            echo ""
          ENDSSH
      
      - name: Deploy Sandbox
        if: needs.detect-changes.outputs.sandbox == 'true'
        env:
          ACR_URL: ${{ secrets.ACR_URL }}
        run: |
          echo "========================================"
          echo "Deploying Sandbox Website"
          echo "========================================"

          # Export vars for SSH session
          ACR_URL="${{ secrets.ACR_URL }}"

          ssh -i ~/.ssh/deploy_key ${{ secrets.VM_ADMIN_USERNAME }}@${{ steps.get-ip.outputs.vm_ip }} \
            "ACR_URL='${ACR_URL}' bash -s" << 'ENDSSH'
            set -e
            cd /opt/docker

            echo "Step 1/3: Pulling latest Sandbox image from ACR..."
            sudo docker pull ${ACR_URL}/sandbox:latest

            echo "Step 2/3: Deploying Sandbox container..."
            # Deploy WITHOUT restarting other services
            sudo docker compose up -d --no-deps sandbox

            echo "Step 3/3: Verifying Sandbox health..."
            echo "  Waiting for Sandbox website endpoint (max 60s)..."
            SANDBOX_HEALTHY=false
            for i in {1..30}; do
              # Test the endpoint directly (using wget since curl not available in Node Alpine)
              if sudo docker exec sandbox_website wget -q -O- http://localhost:3000/ > /dev/null 2>&1; then
                echo ""
                echo "  âœ“ Sandbox website endpoint responding"
                SANDBOX_HEALTHY=true
                break
              fi
              if [ $i -eq 30 ]; then
                echo ""
                echo "  âœ— Sandbox endpoint not responding after 60 seconds"
                echo "  Container status:"
                sudo docker ps | grep sandbox_website
                echo "  Sandbox logs:"
                sudo docker logs sandbox_website --tail 50
                exit 1
              fi
              echo -n "."
              sleep 2
            done

            # Verify endpoint responds
            if [ "$SANDBOX_HEALTHY" = true ]; then
              echo "  Testing Sandbox website endpoint..."
              if curl -f -s -o /dev/null -w "  Sandbox Website: %{http_code}\n" http://localhost:3000/; then
                echo "  âœ“ Sandbox website is responding correctly"
              else
                echo "  âš  Sandbox website health endpoint not responding"
                sudo docker logs sandbox_website --tail 30
                # Don't fail, nginx will handle it gracefully
              fi
            fi

            echo ""
            echo "âœ… Sandbox deployment completed successfully"
            echo ""
          ENDSSH

      - name: Restart Nginx Safely
        if: needs.detect-changes.outputs.reframe == 'true' || needs.detect-changes.outputs.sandbox == 'true'
        run: |
          echo "========================================"
          echo "Restarting Nginx (All services healthy)"
          echo "========================================"

          ssh -i ~/.ssh/deploy_key ${{ secrets.VM_ADMIN_USERNAME }}@${{ steps.get-ip.outputs.vm_ip }} << 'ENDSSH'
            set -e
            cd /opt/docker

            echo "Verifying all upstream services are healthy before nginx restart..."

            # Check Reframe
            if sudo docker ps -a | grep -q reframe_api; then
              if ! sudo docker ps | grep -q "reframe_api.*healthy"; then
                echo "âš  Warning: Reframe is not healthy, but proceeding with nginx restart"
                echo "   Nginx will gracefully handle upstream failures"
              else
                echo "  âœ“ Reframe is healthy"
              fi
            fi

            # Check Sandbox
            if sudo docker ps -a | grep -q sandbox_website; then
              if ! sudo docker ps | grep -q "sandbox_website.*healthy"; then
                echo "âš  Warning: Sandbox is not healthy, but proceeding with nginx restart"
                echo "   Nginx will gracefully handle upstream failures"
              else
                echo "  âœ“ Sandbox is healthy"
              fi
            fi

            # Check Ghost
            if sudo docker ps -a | grep -q ghost_cms; then
              if ! sudo docker ps | grep -q "ghost_cms.*Up"; then
                echo "âš  Warning: Ghost is not running"
              else
                echo "  âœ“ Ghost is running"
              fi
            fi

            echo ""
            echo "Restarting nginx to pick up any service changes..."
            sudo docker compose restart nginx

            # Wait for nginx to stabilize
            echo "Waiting for nginx to stabilize..."
            sleep 10

            # Verify nginx is healthy
            if sudo docker ps | grep -q "main_nginx.*healthy"; then
              echo "âœ… Nginx restarted successfully and is healthy"
            elif sudo docker ps | grep -q "main_nginx.*Restarting"; then
              echo "âœ— ERROR: Nginx entered restart loop!"
              echo "Nginx logs:"
              sudo docker logs main_nginx --tail 50

              echo ""
              echo "Attempting to restore from rollback..."
              # Find most recent rollback
              ROLLBACK=$(ls -t nginx.rollback.* 2>/dev/null | head -1)
              if [ -n "$ROLLBACK" ]; then
                echo "Restoring nginx config from: $ROLLBACK"
                sudo rm -rf nginx
                sudo mv "$ROLLBACK" nginx
                sudo docker compose restart nginx
                sleep 5
                if sudo docker ps | grep -q "main_nginx.*healthy"; then
                  echo "âœ“ Rollback successful, nginx is healthy"
                else
                  echo "âœ— Rollback failed, manual intervention required"
                fi
              fi
              exit 1
            else
              echo "âš  Nginx status unclear, checking logs..."
              sudo docker logs main_nginx --tail 20
            fi

            echo ""
            echo "âœ… Nginx restart completed"
          ENDSSH

      - name: Run health checks
        run: |
          VM_IP=${{ steps.get-ip.outputs.vm_ip }}

          echo "Running health checks..."
          echo "Note: Services may take a moment to fully start"

          # Give services time to start
          sleep 30

          # Check all container statuses
          echo "Checking Docker container health..."
          ssh -i ~/.ssh/deploy_key ${{ secrets.VM_ADMIN_USERNAME }}@$VM_IP << 'EOF'
            set -e

            # Check nginx is healthy
            if sudo docker ps | grep -q "main_nginx.*Up.*healthy"; then
              echo "âœ“ Nginx is healthy"
            elif sudo docker ps | grep -q "main_nginx.*Restarting"; then
              echo "âœ— ERROR: Nginx is in restart loop!"
              echo "Nginx logs:"
              sudo docker logs main_nginx --tail 30

              # Try to identify and fix common issues
              echo "Checking for duplicate upstream definitions..."
              sudo docker run --rm -v /opt/docker/nginx:/etc/nginx:ro nginx:alpine nginx -T 2>&1 | grep -E "duplicate upstream" || true
              exit 1
            else
              echo "âš  Warning: Nginx status unknown"
              sudo docker ps | grep nginx || true
            fi

            # Check other critical services
            SERVICES=("ghost_cms" "reframe_api" "sandbox_website")
            for service in "${SERVICES[@]}"; do
              if sudo docker ps | grep -q "$service.*Up"; then
                echo "âœ“ $service is running"
              else
                echo "âš  Warning: $service may not be running properly"
              fi
            done

            echo ""
            echo "Container Summary:"
            sudo docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
          EOF

          # Check main website (nginx default or website)
          curl -f -s -o /dev/null -w "Website HTTP check: %{http_code}\n" http://$VM_IP || true

          echo "Health checks completed. Services should be accessible via domain names after DNS propagation."
      
      - name: Setup SSL Certificates
        if: github.event_name == 'workflow_run' || github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && github.event.inputs.setup_ssl != 'false')
        run: |
          VM_IP=${{ steps.get-ip.outputs.vm_ip }}
          EMAIL="${{ secrets.EMAIL_ADDRESS }}"
          DOMAIN="${DOMAIN_NAME}"
          
          echo "Checking SSL certificates status..."
          
          # Check if certificates already exist and are valid
          CERT_CHECK=$(ssh -i ~/.ssh/deploy_key ${{ secrets.VM_ADMIN_USERNAME }}@$VM_IP << EOF || echo "NEEDS_SETUP"
            # Check if main certificate exists and is valid
            DOMAIN_NAME="${DOMAIN}"
            if [ -f /etc/letsencrypt/live/www.\${DOMAIN_NAME}/fullchain.pem ]; then
              # Check expiry date (renew if less than 30 days remaining)
              if openssl x509 -checkend 2592000 -noout -in /etc/letsencrypt/live/www.\${DOMAIN_NAME}/fullchain.pem 2>/dev/null; then
                echo "VALID"
              else
                echo "EXPIRING_SOON"
              fi
            else
              echo "NEEDS_SETUP"
            fi
          EOF
          )
          
          if [ "$CERT_CHECK" = "VALID" ]; then
            echo "âœ“ SSL certificates are valid and not expiring soon. Skipping renewal."
          else
            if [ "$CERT_CHECK" = "EXPIRING_SOON" ]; then
              echo "âš  SSL certificates expiring within 30 days. Renewing..."
            else
              echo "ðŸ“‹ Setting up SSL certificates for the first time..."
            fi
            
            # Copy SSL setup script to server
            scp -i ~/.ssh/deploy_key scripts/setup-ssl-automated.sh ${{ secrets.VM_ADMIN_USERNAME }}@$VM_IP:~/
            
            # Run SSL setup
            ssh -i ~/.ssh/deploy_key ${{ secrets.VM_ADMIN_USERNAME }}@$VM_IP << EOF
              chmod +x ~/setup-ssl-automated.sh
              ~/setup-ssl-automated.sh $VM_IP "$EMAIL" "$DOMAIN"
          EOF
            
            echo "SSL setup completed"
          fi

      - name: Docker Cleanup
        if: success()
        run: |
          VM_IP=${{ steps.get-ip.outputs.vm_ip }}

          echo "Running Docker cleanup on VM to free up disk space..."

          # Copy cleanup script to VM
          scp -i ~/.ssh/deploy_key scripts/docker-cleanup.sh ${{ secrets.VM_ADMIN_USERNAME }}@$VM_IP:~/

          # Run cleanup script
          ssh -i ~/.ssh/deploy_key ${{ secrets.VM_ADMIN_USERNAME }}@$VM_IP << 'EOF'
            chmod +x ~/docker-cleanup.sh
            ~/docker-cleanup.sh
          EOF

          echo "âœ“ Docker cleanup completed"

      - name: Cleanup
        if: always()
        run: |
          rm -f ~/.ssh/deploy_key
          rm -f terraform-outputs.zip vm_public_ip.txt storage_account.txt